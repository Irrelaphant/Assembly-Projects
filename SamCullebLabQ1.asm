.386
.model flat, stdcall
.stack 4096
ExitProcess PROTO, dwExitCode: DWORD
INCLUDE Irvine32.inc


;Sam Cullen COSC-220 Final Project, Snake Game
;
;Sources: 
;
;
;https://www.youtube.com/watch?v=iRcXMPIDJHY&t
;https://github.com/NikitaIvanovV/snake-asm/blob/master/snake.asm
;
;
.data

;the "wall" array is full of the ASCII character that creates a block
xWall BYTE 52 DUP(219),0

;This is the corners of the wall, so its the top left, top right, bottem left and bottom right corner coordinates. 
xPosWall BYTE 34,34,85,85			
yPosWall BYTE 1,26,1,26

;A variable to store the actual decimal value of the score, and the string to be printed when the score is displayed
strScore BYTE "score: ",0
score BYTE 0

;the snake starts with the ASCII 153 simple which is the letter O with the little dots on top, I thought it looked a bit like a funny face
snake BYTE 153, 104 DUP("o")

;the player position array
xPos BYTE 45,44,43,42,41, 100 DUP(?)
yPos BYTE 15,15,15,15,15, 100 DUP(?)

;All of these strings are printed whenever there is an outcome from the snake
;so when you die try again gets printed, when you input a invalid input invalid input prints, and so on
strTryAgain BYTE "Start Over?  1=yes, 0=no",0
invalidInput BYTE "invalid input",0
strDeath BYTE "you died ",0
strPrintingScore BYTE " point(s)",0

;the blank byte is to fill in the space of the array to clear the last input
blank BYTE "                                     ",0

;the x and y that are randomly generated by the GetRandomCoinLocation PROC puts two random numbers into these x and y values
xCoin BYTE ?
yCoin BYTE ?

;Input char is set to "+" at the start of the game that way if the game hasn't started left, the first input can't be left. So the snake cant go inside itself
inputChar BYTE "+"					
lastInputChar BYTE ?				

;The stirng and variable to store the speed and the string to print when asking
strDifficulty BYTE "Level: ",0
speed	DWORD 0

;same for this, strings to be printed in the title sequence
strTitleSentence BYTE "Welcome to my Snake Game!", 0
strSpaceToStart BYTE "please press space to start :)", 0
strInstructions BYTE "Pick a difficulty (1-3) after pressing space to start"
.code
main PROC

	call TitleScreen

	call DrawWall			
	call DrawPoints		
	call Difficulty		

	;esi gets set to 0 to point to which part of the snake drawing procedure must begin 
	;ecx is 5 because of how many segments of the snake will be drawn (5-1 since esi gets incremented first) so four sections of the snake body are drawn
	mov esi,0
	mov ecx,5
drawSnake:

	;drawplayer draws the snake, this procedure exists though so that when the game and the player requested to restart
	;this procedure can get called again so the snake can be redrawn at the starting position
	call DrawPlayer			
	inc esi
loop drawSnake
	
		;this is the process used to generate random numbers for the coin, place it on the grid and since the snake has been generated we 
		;are able to check whether or the coin intersects with the snakes body
	call Randomize
	call CreateRandom
	call DrawCoin			

	
	gameLoop:

		;this moves the curser to these coordinates here 
		mov dl,1						
		mov dh,1
		call Gotoxy

		;get the key input and more importantly, jumps if nothing gets input 
		call ReadKey
        jz noKey						
		processInput:
		mov bl, inputChar
		mov lastInputChar, bl
		mov inputChar,al				

		noKey:

			;at any point in time if the play inputs "x", the game will end
			cmp inputChar,"x"	
			je exitgame						

			;all of these are the game inputs and the respective border in the game they must check if they are colliding into
			;
			cmp inputChar,"w"
			je checkTop

			cmp inputChar,"s"
			je checkBottom

			cmp inputChar,"a"
			je checkLeft

			cmp inputChar,"d"
			je checkRight

				;if nothing else was entered, it goes back up to the top
				jne gameLoop					


			;All of these are the procedures used to check if the wall is going to collide with the player 
			checkBottom:	
				cmp lastInputChar, "w"
				je dontChgDirection		;cant go down after going up
				mov cl, yPosWall[1]
				dec cl					;one unit ubove the y-coordinate of the lower bound
				cmp yPos[0],cl
				jl moveDown
				je died					;die if the snake touchez into da wall

			checkLeft:		

					;So when the game starts the lastInputChar variable is set to "+", that way when you are in the starting position (facing right) the snake still can't turn into itself				
					cmp lastInputChar, "+"	
				
				je dontGoLeft
				cmp lastInputChar, "d"
				je dontChgDirection
				mov cl, xPosWall[0]
				inc cl
				cmp xPos[0],cl
				jg moveLeft
				je died					

			checkRight:		
				cmp lastInputChar, "a"
				je dontChgDirection
				mov cl, xPosWall[2]
				dec cl
				cmp xPos[0],cl
				jl moveRight
				je died						

			checkTop:		
				cmp lastInputChar, "s"
				je dontChgDirection
				mov cl, yPosWall[0]
				inc cl
				cmp yPos,cl
				jg moveUp
				je died					
		

		moveUp:		

			;so an issue I had with this was when moving up, its a obviously a different amount of columns vs rows, so if the same speed was kept
			;the snake player would end up going crazy fast, so I have a delay called (that is set based off the difficulty)
			;the delay gets enabled anytime you move up or down, solving the speed issue
			mov eax, speed		
			add eax, speed
			call delay

			;esi index 0 is the snake head
			mov esi, 0		
			
			call UpdatePlayer	
			mov ah, yPos[esi]	
			mov al, xPos[esi]	;al and ah stores the pos of the snakes next unit 
			dec yPos[esi]		;moves the head up by decrementing the value and then after you go up it 
			call DrawPlayer		
			call DrawBody
			call CheckIfTouch

		
		;move up is the same, but instead of decrementing, it increases, that way the head moves downward
		moveDown:			
			mov eax, speed
			add eax, speed
			call delay
			mov esi, 0
			call UpdatePlayer
			mov ah, yPos[esi]
			mov al, xPos[esi]
			inc yPos[esi]
			call DrawPlayer
			call DrawBody
			call CheckIfTouch


		
		;Move left and move right are pretty simple, its the same idea but instead of calling a delay twice as long its only the normal delay
		;that is based off of the difficulty

		moveLeft:		
			mov eax, speed
			call delay
			mov esi, 0
			call UpdatePlayer
			mov ah, yPos[esi]
			mov al, xPos[esi]
			dec xPos[esi]
			call DrawPlayer
			call DrawBody
			call CheckIfTouch
		moveRight:		
		
			mov eax, speed
			call delay
			mov esi, 0
			call UpdatePlayer
			mov ah, yPos[esi]
			mov al, xPos[esi]
			inc xPos[esi]
			call DrawPlayer
			call DrawBody
			call CheckIfTouch

	; getting points
		checkcoin::
		mov esi,0
		mov bl,xPos[0]
		cmp bl,xCoin

		;if the snake is not touching the coin reloop
		jne gameloop			
		mov bl,yPos[0]
		cmp bl,yCoin

		;again it is not interecting with the coin reloop
		jne gameloop			

		;if you IS eating the coin.... call eatcoin
		call EatCoin				

jmp gameLoop					
;restarts the gameloop when the player wants

	;can't let the player change direction mid input
	dontChgDirection:		
		;if the direction isn't changed then keep going the same direction
		mov inputChar, bl		
		jmp noKey				

	;can't go left at the start of the game
	dontGoLeft:				
		mov	inputChar, "+"		

		jmp gameLoop			;restart the game loop

	died::
		call PlayerDeath
	 
	playagn::			
		call RestartGame			;reinitialise everything
	
	exitgame::
	exit

INVOKE ExitProcess,0
main ENDP

TitleScreen PROC

    ; Display Snake Game Title Screen
    Call ClrScr
    mov eax, green
	call SetTextColor

	mov dl, 45
	mov dh, 9
	call Gotoxy
	mov edx, OFFSET strTitleSentence
	call WriteString

	mov dl, 38
	mov dh, 14
	call Gotoxy
	mov eax, Red
	call SetTextColor
	mov edx, OFFSET strInstructions
	call WriteString


	mov eax, green
	call SetTextColor
	mov dl, 43
	mov dh, 20
	call Gotoxy

	;wait for space bar for input
    mov edx, OFFSET strSpaceToStart 
    call WriteString

    ; Wait for space bar press
    waitForKey:
    call ReadKey
    cmp al, ' ' ; Check if space bar is pressed
    je startGame
    jmp waitForKey

    startGame:
    Call ClrScr
	mov eax, white
	call SetTextColor
    ret
TitleScreen ENDP

;this is the procedure to restart the entire game if the player inputs 1
RestartGame PROC

	;this will move the snake head to 45
	mov xPos[0], 45
	;this moves the x of the rest of the snakes body parts
	mov xPos[1], 44
	mov xPos[2], 43
	mov xPos[3], 42
	;this is the y coordinates of the snakes head
	mov xPos[4], 41

	;the y positions of the snakes body parts
	mov yPos[0], 15 ;y of the snakes head
	mov yPos[1], 15
	mov yPos[2], 15
	mov yPos[3], 15
	mov yPos[4], 15			

		;this resets the score
	mov score,0				;reinitialize score
		;clear last last input char
	mov lastInputChar, 0
		;the input char gets set to "+" 
	mov	inputChar, "+"			

	
	dec yPosWall[3]			;reset walls position, decrementing it by one will make it redraw the walls because the array will update

	Call ClrScr

	jmp main				;restart the main procedure
RestartGame ENDP

;this draws the wall, it makes the upper, lower then left and right walls by following the array and drawing the block ascii symbol
DrawWall PROC	
		;upper wall
			mov eax, blue
			call SetTextColor
			mov dl,xPosWall[0]
			mov dh,yPosWall[0]
			call Gotoxy	
			mov edx,OFFSET xWall
			call WriteString			

		;lower wall
			mov dl,xPosWall[1]
			mov dh,yPosWall[1]
			call Gotoxy	
			mov edx,OFFSET xWall	
			call WriteString			

	;draw the right wall
		mov dl, xPosWall[2]
		mov dh, yPosWall[2]
		mov eax, 219	
		inc yPosWall[3]
		L11: 
			call Gotoxy	
			call WriteChar	
			inc dh
			cmp dh, yPosWall[3]				
		jl L11

		;draw the wall on the left
		mov dl, xPosWall[0]
		mov dh, yPosWall[0]
		mov eax, 219	
		L12: 
			call Gotoxy	
			call WriteChar	
			inc dh
			cmp dh, yPosWall[3]			
		jl L12

	;set the text color back to normal 
	mov eax, white
	call SetTextColor
	ret

DrawWall ENDP

;this sets the speed of the snake to act as a difficulty measure
Difficulty PROC			
	mov edx,0
	mov dl,1				
	mov dh,1
	call Gotoxy	
	mov edx,OFFSET strDifficulty	; prompt to enter integers (1,2,3)
	call WriteString

	;the amount of delay gets put into esi temporarily
	mov esi, 40				
	mov eax,0
	call readInt			
	cmp ax,1				
	jl invalidspeed
	cmp ax, 3
	jg invalidspeed
	mul esi	
		;then the variable gets a memory register
	mov speed, eax			
	ret

	;if the user entered something that is not a usable input use this
	invalidspeed:			
		mov dl,105				
		mov dh,1
		call Gotoxy	

	;prints the invalid input error code
	mov edx, OFFSET invalidInput				
	call WriteString
	mov ax, 1500
	call delay
	mov dl,105				
	mov dh,1
	call Gotoxy	

	;after one and a half seconds, erase the invalid input message by printing the blank string instead
	mov edx, OFFSET blank				
	call writeString
	
	;go back to the start so the user can input something functional
	call Difficulty					
	ret

Difficulty ENDP


DrawPoints PROC		

	;go to this x and y in the terminal and print the "str score" string, and then write the actual value of the score
	mov dl, 10
	mov dh, 3
	call Gotoxy
	mov edx,OFFSET strScore		

	call WriteString
	mov eax,"0" ;your score starts as zero
	call WriteChar				
	ret

DrawPoints ENDP




DrawPlayer PROC			; draw player at (xPos,yPos)
	
	
	mov dl,xPos[esi]
	mov dh,yPos[esi]
	call Gotoxy
	mov dl, al			;temporarily save al in dl
	mov al, snake[esi]		
	call WriteChar
	mov al, dl			
	ret

DrawPlayer ENDP

DrawBody PROC				
		;procedure to print body of the snake
		mov ecx, 4
		add cl, score		;number of iterations to print the snake body n tail	

		printbodyloop:	

			inc esi				;loop to print remaining units of snake
			call UpdatePlayer
				;dl and dh will temporilty store the current position of the snakes body unit
			mov dl, xPos[esi]
			mov dh, yPos[esi]	
				;the position then gets updated based off the position of esi in the stack, so whatever body part of the snake according to esi
			mov yPos[esi], ah
			mov xPos[esi], al	

			;the current position gets put back into al and ah
			mov al, dl
			mov ah,dh			
		call DrawPlayer
		cmp esi, ecx
		jl printbodyloop

	ret
DrawBody ENDP

UpdatePlayer PROC		
	;this will delete the last section of the snake by replacing it with a "blank" mark
		mov dl, xPos[esi]
		mov dh, yPos[esi]
	;us al to temporily store the location
		call Gotoxy
		mov dl, al			
		mov al, " "

		;prints the empty character and then restores dl
	call WriteChar
	mov al, dl ;reset
	ret

UpdatePlayer ENDP

CreateRandom PROC				
		;This procedure creates a random x and y value for the coin by using the random range function
		;the random range guesses between 0 and 45 since 45 gets moved into eax, and then 40 is added that way it is added to fit inside the player grid
	mov eax,45
	call RandomRange	
	add eax, 40			
	mov xCoin, al

		;The same thing happens but coordinates with the y values, making the coins y position random and adding 6 so it fits within the range of the player boundries
	mov eax,17
	call RandomRange	
	add eax, 3			
	mov yCoin, al

	mov ecx, 5
		;This is looped based off the actual score
	add cl, score				
	mov esi, 0

		checkCoinXPos:

			movzx eax,  xCoin
			cmp al, xPos[esi]		
			je checkCoinYPos			;jump if xPos of snake at esi = xPos of coin
			continueloop:
				inc esi
					loop checkCoinXPos
					;the function will return if the snake aint touchin da coin
				ret							

				checkCoinYPos:
					movzx eax, yCoin
	
				cmp al, yPos[esi] ;compares the y value of the snake head to the coin 

			jne continueloop			; jump back to continue loop if yPos of snake at esi != yPos of coin
			call CreateRandom			; coin generated on snake, calling function again to create another set of coordinates

CreateRandom ENDP

DrawCoin PROC						

		;procedure to draw coin
			mov eax,yellow (yellow * 16)
			call SetTextColor				
		;set color to yellow for coin
			mov dl,xCoin
			mov dh,yCoin
			call Gotoxy
	
		mov al, 254
		call WriteChar
		mov eax,white (black * 16)		;reset color to black and white
		call SetTextColor
		ret

DrawCoin ENDP



CheckIfTouch PROC		
		;check whether the snake head collides w its body 
	mov al, xPos[0] 
	mov ah, yPos[0] 
	mov esi,4				;start checking from index 4(5th unit)
	mov ecx,1
	add cl,score
		checkXposition:
			cmp xPos[esi], al		;check if xpos same ornot
			je XposSame
			contloop:
			inc esi
		loop checkXposition

	jmp checkcoin
	XposSame:				; if xpos same, check for ypos
	cmp yPos[esi], ah
	je died					;if collides, snake dies
	jmp contloop

CheckIfTouch ENDP



EatCoin PROC
	
	;Whenever the snake eats a coin this procedure should be called
	;this proc will increase the score, as well as call the other two procedures for the coin
	;creating a new random location for the coin while also checking the collision, and also placing the new coin

	inc score
		mov ebx,4
		add bl, score
		mov esi, ebx
		mov ah, yPos[esi-1]
		mov al, xPos[esi-1]	
		mov xPos[esi], al		;add one unit to the snake
		mov yPos[esi], ah		;pos of new tail = pos of old tail

		cmp xPos[esi-2], al		;check if the old tail and the unit before is on the yAxis
		jne checky				;jump if not on the yAxis

	cmp yPos[esi-2], ah		;check if the new tail should be above or below of the old tail 
		jl incy			
		jg decy
			;increment if its above
		incy:					
		inc yPos[esi]
		jmp continue
			;decriment if it is aboved
		decy:					
		dec yPos[esi]
		jmp continue

		;the old tail and the unit before on the x axis gets checked
		checky:					
			cmp yPos[esi-2], ah		
			jl incx
			jg decx
			incx:					;inc if right
			inc xPos[esi]			
			jmp continue
			decx:					;dec if left
			dec xPos[esi]

	continue:				;add snake tail and update new coin
		call DrawPlayer		
		call CreateRandom
		call DrawCoin			

		;this prints the updates score 
		mov dl,16				
		mov dh,3
		call Gotoxy
		mov al,score
		call WriteInt
		ret
EatCoin ENDP


PlayerDeath PROC
	
	;upon death, to simulate real life, there is a brief moment where all the snakes memories will flood back all at once
	;this is why there is a delay
	mov eax, 1000
	call delay
	Call ClrScr	
	
	;in red text this will print the text that "you died"
		mov dl,	15
		mov dh, 12
		call Gotoxy
		mov eax, red
		call SetTextColor
		;prints "you died :(" in red
		mov edx, OFFSET strDeath	
		call WriteString
		mov eax, white
		call SetTextColor

		;this displays your overall score
			mov dl,	13
			mov dh, 14
			call Gotoxy
			movzx eax, score
			;prints the score
			call WriteInt
			mov edx, OFFSET strPrintingScore	;display score
			call WriteString

		;this will print "try again"
			mov dl,	10
			mov dh, 18
			call Gotoxy
			mov edx, OFFSET strTryAgain
			call WriteString		

	retry:
		mov dh, 10
		mov dl,	1
		call Gotoxy
		call ReadInt			
	
			;if the player enters 1, the game restarts
		cmp al, 1
		je playagn
	
		;if they choose zero, the game closes
		cmp al, 0
		je exitgame				

		mov dh,	17
		call Gotoxy

		;if the input is wrong, it will print "invalid input"
		mov edx, OFFSET invalidInput	
		call WriteString		

		mov dl,	56
		mov dh, 19
		call Gotoxy

				;removes the previous input, deletes it by writing a big blank string, then jumps back to the start
			mov edx, OFFSET blank			
			call WriteString
			jmp retry						;let user input again by jumping back

PlayerDeath ENDP



END main